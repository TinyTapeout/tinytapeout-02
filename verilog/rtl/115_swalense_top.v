/* Generated by Yosys 0.23+8 (git sha1 48659ee2b, clang 14.0.0 -fPIC -Os) */

module counter(rst, wrap, init_value, max_value, inc, strobe, reset, value, updating_strobe, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$1  = 0;
  wire \$1 ;
  wire [9:0] \$11 ;
  wire [8:0] \$12 ;
  wire [8:0] \$14 ;
  wire [1:0] \$15 ;
  wire [9:0] \$18 ;
  wire [7:0] \$20 ;
  wire \$3 ;
  wire \$5 ;
  wire \$7 ;
  wire \$9 ;
  wire can_update;
  input clk;
  wire clk;
  input inc;
  wire inc;
  input [7:0] init_value;
  wire [7:0] init_value;
  input [7:0] max_value;
  wire [7:0] max_value;
  input reset;
  wire reset;
  input rst;
  wire rst;
  input strobe;
  wire strobe;
  output updating_strobe;
  wire updating_strobe;
  output [7:0] value;
  reg [7:0] value = 8'h00;
  reg [7:0] \value$next ;
  input wrap;
  wire wrap;
  assign \$9  = strobe & \$7 ;
  assign \$12  = + value;
  assign \$15  = inc ? 2'h1 : 2'h3;
  assign \$14  = + $signed(\$15 );
  assign \$18  = $signed(\$12 ) + $signed(\$14 );
  assign \$1  = value != max_value;
  assign \$20  = inc ? 8'h00 : max_value;
  always @(posedge clk)
    value <= \value$next ;
  assign \$3  = | value;
  assign \$5  = inc ? \$1  : \$3 ;
  assign \$7  = wrap | can_update;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    \value$next  = value;
    casez ({ updating_strobe, reset })
      2'b?1:
          \value$next  = init_value;
      2'b1?:
          (* full_case = 32'd1 *)
          casez (can_update)
            1'h1:
                \value$next  = \$18 [7:0];
            default:
                \value$next  = \$20 ;
          endcase
    endcase
    casez (rst)
      1'h1:
          \value$next  = 8'h00;
    endcase
  end
  assign \$11  = \$18 ;
  assign updating_strobe = \$9 ;
  assign can_update = \$5 ;
endmodule

module decoder(rst, channels, direction, force_x2, debounce, x1_value, strobe_x2, strobe_x4, strobe_x1, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$2  = 0;
  wire \$1 ;
  wire \$11 ;
  wire \$13 ;
  wire \$15 ;
  wire \$17 ;
  wire \$19 ;
  wire \$21 ;
  wire \$23 ;
  wire \$25 ;
  wire \$27 ;
  wire \$29 ;
  wire \$3 ;
  wire [1:0] \$5 ;
  wire \$7 ;
  wire \$9 ;
  input [1:0] channels;
  wire [1:0] channels;
  input clk;
  wire clk;
  input debounce;
  wire debounce;
  wire dir;
  output direction;
  reg direction = 1'h0;
  reg \direction$next ;
  input force_x2;
  wire force_x2;
  reg [1:0] prev_channels = 2'h0;
  reg [1:0] \prev_channels$next ;
  input rst;
  wire rst;
  output strobe_x1;
  wire strobe_x1;
  output strobe_x2;
  wire strobe_x2;
  output strobe_x4;
  reg strobe_x4 = 1'h0;
  reg \strobe_x4$next ;
  input [1:0] x1_value;
  wire [1:0] x1_value;
  assign \$9  = \$3  | \$7 ;
  assign \$11  = strobe_x4 & \$9 ;
  assign \$13  = channels == x1_value;
  assign \$15  = strobe_x4 & \$13 ;
  assign \$17  = force_x2 ? strobe_x2 : \$15 ;
  assign \$1  = channels[0] ^ prev_channels[1];
  assign \$19  = channels != prev_channels;
  assign \$21  = dir == direction;
  assign \$23  = ~ debounce;
  assign \$25  = \$21  | \$23 ;
  assign \$27  = channels != prev_channels;
  assign \$29  = channels != prev_channels;
  always @(posedge clk)
    strobe_x4 <= \strobe_x4$next ;
  always @(posedge clk)
    prev_channels <= \prev_channels$next ;
  always @(posedge clk)
    direction <= \direction$next ;
  assign \$3  = channels == x1_value;
  assign \$5  = ~ x1_value;
  assign \$7  = channels == \$5 ;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \strobe_x4$next  = 1'h0;
    casez (\$19 )
      1'h1:
          \strobe_x4$next  = \$25 ;
    endcase
    casez (rst)
      1'h1:
          \strobe_x4$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \prev_channels$next  = prev_channels;
    casez (\$27 )
      1'h1:
          \prev_channels$next  = channels;
    endcase
    casez (rst)
      1'h1:
          \prev_channels$next  = channels;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \direction$next  = direction;
    casez (\$29 )
      1'h1:
          \direction$next  = dir;
    endcase
    casez (rst)
      1'h1:
          \direction$next  = 1'h0;
    endcase
  end
  assign strobe_x1 = \$17 ;
  assign strobe_x2 = \$11 ;
  assign dir = \$1 ;
endmodule

module dev(rst, channels, force_x2, cs, sck, sdi, tx, pwm_signal, direction, counter, clk);
  wire \$2 ;
  wire \$4 ;
  wire \$6 ;
  wire [1:0] \$signal ;
  input [1:0] channels;
  wire [1:0] channels;
  input clk;
  wire clk;
  output [7:0] counter;
  wire [7:0] counter;
  wire counter_inc;
  wire [7:0] counter_init_value;
  wire [7:0] counter_max_value;
  wire counter_reset;
  wire counter_strobe;
  wire counter_updating_strobe;
  wire [7:0] counter_value;
  wire counter_wrap;
  input cs;
  wire cs;
  wire decoder_debounce;
  wire decoder_force_x2;
  wire decoder_strobe_x1;
  wire decoder_strobe_x2;
  wire decoder_strobe_x4;
  wire [1:0] decoder_x1_value;
  output direction;
  wire direction;
  input force_x2;
  wire force_x2;
  wire gearbox_enable;
  wire gearbox_strobe;
  wire [7:0] gearbox_timer_cycles;
  wire [7:0] pwm_duty;
  wire [7:0] pwm_max_duty;
  output pwm_signal;
  wire pwm_signal;
  input rst;
  wire rst;
  input sck;
  wire sck;
  input sdi;
  wire sdi;
  wire serial_out_strobe;
  wire [7:0] serial_out_word;
  wire spi_busy;
  wire spi_cs;
  wire [31:0] spi_data;
  wire spi_force_x2;
  wire spi_sck;
  wire spi_sdi;
  wire spi_strobe;
  output tx;
  wire tx;
  assign \$2  = force_x2 | spi_force_x2;
  assign \$4  = ~ spi_busy;
  assign \$6  = \$4  & gearbox_strobe;
  counter \counter$1  (
    .clk(clk),
    .inc(counter_inc),
    .init_value(counter_init_value),
    .max_value(counter_max_value),
    .reset(counter_reset),
    .rst(rst),
    .strobe(counter_strobe),
    .updating_strobe(counter_updating_strobe),
    .value(counter_value),
    .wrap(counter_wrap)
  );
  decoder decoder (
    .channels(channels),
    .clk(clk),
    .debounce(decoder_debounce),
    .direction(direction),
    .force_x2(decoder_force_x2),
    .rst(rst),
    .strobe_x1(decoder_strobe_x1),
    .strobe_x2(decoder_strobe_x2),
    .strobe_x4(decoder_strobe_x4),
    .x1_value(decoder_x1_value)
  );
  gearbox gearbox (
    .clk(clk),
    .enable(gearbox_enable),
    .rst(rst),
    .strobe(gearbox_strobe),
    .strobe_x1(decoder_strobe_x1),
    .strobe_x2(decoder_strobe_x2),
    .strobe_x4(decoder_strobe_x4),
    .timer_cycles(gearbox_timer_cycles)
  );
  pwm pwm (
    .clk(clk),
    .duty(pwm_duty),
    .max_duty(pwm_max_duty),
    .pwm_signal(pwm_signal),
    .rst(rst)
  );
  serial_out serial_out (
    .clk(clk),
    .rst(rst),
    .strobe(serial_out_strobe),
    .tx(tx),
    .word(serial_out_word)
  );
  spi spi (
    .busy(spi_busy),
    .clk(clk),
    .cs(spi_cs),
    .data(spi_data),
    .rst(rst),
    .sck(spi_sck),
    .sdi(spi_sdi),
    .strobe(spi_strobe)
  );
  assign serial_out_strobe = counter_updating_strobe;
  assign serial_out_word = counter_value;
  assign pwm_max_duty = counter_max_value;
  assign pwm_duty = counter_value;
  assign counter = counter_value;
  assign counter_reset = spi_strobe;
  assign counter_strobe = \$6 ;
  assign counter_inc = direction;
  assign { counter_max_value, counter_init_value, gearbox_timer_cycles, \$signal , spi_force_x2, decoder_x1_value, decoder_debounce, counter_wrap, gearbox_enable } = spi_data;
  assign spi_sdi = sdi;
  assign spi_sck = sck;
  assign spi_cs = cs;
  assign decoder_force_x2 = \$2 ;
endmodule

module gearbox(rst, enable, timer_cycles, strobe, strobe_x2, strobe_x4, strobe_x1, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$3  = 0;
  wire [8:0] \$1 ;
  wire [5:0] \$10 ;
  wire [5:0] \$11 ;
  wire \$13 ;
  wire \$14 ;
  wire \$17 ;
  wire [5:0] \$19 ;
  wire [8:0] \$2 ;
  wire [5:0] \$20 ;
  wire [4:0] \$22 ;
  wire [4:0] \$23 ;
  wire [1:0] \$25 ;
  wire \$27 ;
  wire \$29 ;
  wire \$31 ;
  wire \$4 ;
  wire \$6 ;
  wire \$8 ;
  input clk;
  wire clk;
  input enable;
  wire enable;
  wire [1:0] g;
  wire [1:0] gear;
  reg [7:0] period = 8'h7f;
  reg [7:0] \period$next ;
  input rst;
  wire rst;
  output strobe;
  reg strobe;
  input strobe_x1;
  wire strobe_x1;
  input strobe_x2;
  wire strobe_x2;
  input strobe_x4;
  wire strobe_x4;
  reg [4:0] threshold = 5'h00;
  reg [4:0] \threshold$next ;
  input [7:0] timer_cycles;
  wire [7:0] timer_cycles;
  assign \$11  = threshold - 1'h1;
  assign \$14  = & threshold;
  assign \$13  = ~ \$14 ;
  assign \$17  = strobe_x4 & \$13 ;
  assign \$20  = threshold + 1'h1;
  assign \$25  = g[1] ? 2'h2 : g;
  assign \$2  = period + 1'h1;
  assign \$29  = enable ? strobe_x2 : strobe_x1;
  assign \$31  = enable ? strobe_x4 : strobe_x1;
  always @(posedge clk)
    period <= \period$next ;
  always @(posedge clk)
    threshold <= \threshold$next ;
  assign \$4  = period == timer_cycles;
  assign \$6  = period == timer_cycles;
  assign \$8  = | threshold;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    \period$next  = \$2 [7:0];
    casez (\$4 )
      1'h1:
          \period$next  = 8'h00;
    endcase
    casez (rst)
      1'h1:
          \period$next  = 8'h7f;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    \threshold$next  = threshold;
    casez (\$6 )
      1'h1:
          casez (\$8 )
            1'h1:
                \threshold$next  = \$11 [4:0];
          endcase
    endcase
    casez (\$17 )
      1'h1:
          \threshold$next  = \$20 [4:0];
    endcase
    casez (rst)
      1'h1:
          \threshold$next  = 5'h00;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    (* full_case = 32'd1 *)
    casez (gear)
      2'h0:
          strobe = \$27 ;
      2'h1:
          strobe = \$29 ;
      2'h?:
          strobe = \$31 ;
    endcase
  end
  assign \$1  = \$2 ;
  assign \$10  = \$11 ;
  assign \$19  = \$20 ;
  assign \$22  = \$23 ;
  assign gear = \$25 ;
  assign g = \$23 [1:0];
  assign \$23  = { 3'h0, threshold[4:3] };
  assign \$27  = strobe_x1;
endmodule

module pwm(rst, pwm_signal, duty, max_duty, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$4  = 0;
  wire [8:0] \$1 ;
  wire \$10 ;
  wire \$12 ;
  wire [8:0] \$2 ;
  wire \$4 ;
  wire \$6 ;
  wire \$8 ;
  input clk;
  wire clk;
  reg [7:0] counter = 8'h00;
  reg [7:0] \counter$next ;
  input [7:0] duty;
  wire [7:0] duty;
  input [7:0] max_duty;
  wire [7:0] max_duty;
  output pwm_signal;
  reg pwm_signal = 1'h0;
  reg \pwm_signal$next ;
  input rst;
  wire rst;
  assign \$10  = counter == duty;
  assign \$12  = | duty;
  always @(posedge clk)
    counter <= \counter$next ;
  always @(posedge clk)
    pwm_signal <= \pwm_signal$next ;
  assign \$2  = counter + 1'h1;
  assign \$4  = counter == max_duty;
  assign \$6  = counter == duty;
  assign \$8  = counter == max_duty;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$4 ) begin end
    \counter$next  = \$2 [7:0];
    casez ({ \$6 , \$4  })
      2'b?1:
          \counter$next  = 8'h00;
    endcase
    casez (rst)
      1'h1:
          \counter$next  = 8'h00;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$4 ) begin end
    \pwm_signal$next  = pwm_signal;
    casez ({ \$10 , \$8  })
      2'b?1:
          \pwm_signal$next  = \$12 ;
      2'b1?:
          \pwm_signal$next  = 1'h0;
    endcase
    casez (rst)
      1'h1:
          \pwm_signal$next  = 1'h0;
    endcase
  end
  assign \$1  = \$2 ;
endmodule

module serial_out(rst, tx, word, strobe, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$5  = 0;
  wire \$1 ;
  wire \$10 ;
  wire [13:0] \$3 ;
  wire \$5 ;
  wire [4:0] \$7 ;
  wire [4:0] \$8 ;
  input clk;
  wire clk;
  reg [13:0] data = 14'h0001;
  reg [13:0] \data$next ;
  reg [3:0] i = 4'h0;
  reg [3:0] \i$next ;
  input rst;
  wire rst;
  reg start = 1'h0;
  reg \start$next ;
  input strobe;
  wire strobe;
  output tx;
  wire tx;
  input [7:0] word;
  wire [7:0] word;
  assign \$10  = | i;
  always @(posedge clk)
    data <= \data$next ;
  always @(posedge clk)
    i <= \i$next ;
  always @(posedge clk)
    start <= \start$next ;
  assign \$1  = | i;
  assign \$3  = + data[13:1];
  assign \$5  = | i;
  assign \$8  = i - 1'h1;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$5 ) begin end
    \data$next  = data;
    casez ({ start, \$1  })
      2'b?1:
          \data$next  = \$3 ;
      2'b1?:
          \data$next  = { 5'h1f, word, 1'h0 };
    endcase
    casez (rst)
      1'h1:
          \data$next  = 14'h0001;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$5 ) begin end
    \i$next  = i;
    casez ({ start, \$5  })
      2'b?1:
          \i$next  = \$8 [3:0];
      2'b1?:
          \i$next  = 4'hd;
    endcase
    casez (rst)
      1'h1:
          \i$next  = 4'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$5 ) begin end
    \start$next  = start;
    casez ({ start, \$10  })
      2'b?1:
          /* empty */;
      2'b1?:
          \start$next  = 1'h0;
    endcase
    casez (strobe)
      1'h1:
          \start$next  = 1'h1;
    endcase
    casez (rst)
      1'h1:
          \start$next  = 1'h0;
    endcase
  end
  assign \$7  = \$8 ;
  assign tx = data[0];
endmodule

module spi(rst, cs, sck, sdi, data, busy, strobe, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$6  = 0;
  wire \$1 ;
  wire \$11 ;
  wire \$13 ;
  wire \$15 ;
  wire \$17 ;
  wire \$19 ;
  wire \$21 ;
  wire \$23 ;
  wire \$25 ;
  wire [6:0] \$27 ;
  wire [6:0] \$28 ;
  wire \$3 ;
  wire \$30 ;
  wire \$32 ;
  wire \$34 ;
  wire \$36 ;
  wire \$38 ;
  wire \$40 ;
  wire \$42 ;
  wire \$44 ;
  wire \$46 ;
  wire \$48 ;
  wire \$5 ;
  wire \$50 ;
  wire \$52 ;
  wire \$7 ;
  wire \$9 ;
  (* \amaranth.sample_reg  = 32'd1 *)
  reg \$sample$s$cs$sync$1  = 1'h0;
  wire \$sample$s$cs$sync$1$next ;
  (* \amaranth.sample_reg  = 32'd1 *)
  reg \$sample$s$sck$sync$1  = 1'h0;
  wire \$sample$s$sck$sync$1$next ;
  output busy;
  reg busy = 1'h0;
  reg \busy$next ;
  input clk;
  wire clk;
  input cs;
  wire cs;
  output [31:0] data;
  reg [31:0] data = 32'd520109572;
  reg [31:0] \data$next ;
  reg [5:0] i = 6'h00;
  reg [5:0] \i$next ;
  input rst;
  wire rst;
  input sck;
  wire sck;
  input sdi;
  wire sdi;
  output strobe;
  reg strobe = 1'h0;
  reg \strobe$next ;
  assign \$9  = ~ \$sample$s$sck$sync$1 ;
  assign \$11  = \$9  & sck;
  assign \$13  = i == 6'h20;
  assign \$15  = ~ cs;
  assign \$17  = \$sample$s$cs$sync$1  & \$15 ;
  assign \$1  = ~ cs;
  assign \$19  = ~ \$sample$s$cs$sync$1 ;
  assign \$21  = \$19  & cs;
  assign \$23  = ~ \$sample$s$sck$sync$1 ;
  assign \$25  = \$23  & sck;
  assign \$28  = i + 1'h1;
  assign \$30  = ~ cs;
  assign \$32  = \$sample$s$cs$sync$1  & \$30 ;
  assign \$34  = ~ \$sample$s$cs$sync$1 ;
  assign \$36  = \$34  & cs;
  assign \$38  = ~ \$sample$s$sck$sync$1 ;
  assign \$3  = \$sample$s$cs$sync$1  & \$1 ;
  assign \$40  = \$38  & sck;
  assign \$42  = ~ cs;
  assign \$44  = \$sample$s$cs$sync$1  & \$42 ;
  assign \$46  = ~ \$sample$s$cs$sync$1 ;
  assign \$48  = \$46  & cs;
  assign \$50  = ~ \$sample$s$sck$sync$1 ;
  assign \$52  = \$50  & sck;
  always @(posedge clk)
    \$sample$s$cs$sync$1  <= \$sample$s$cs$sync$1$next ;
  always @(posedge clk)
    \$sample$s$sck$sync$1  <= \$sample$s$sck$sync$1$next ;
  always @(posedge clk)
    strobe <= \strobe$next ;
  always @(posedge clk)
    i <= \i$next ;
  always @(posedge clk)
    busy <= \busy$next ;
  always @(posedge clk)
    data <= \data$next ;
  assign \$5  = ~ \$sample$s$cs$sync$1 ;
  assign \$7  = \$5  & cs;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$6 ) begin end
    \strobe$next  = 1'h0;
    casez ({ busy, \$3  })
      2'b?1:
          /* empty */;
      2'b1?:
          casez ({ \$11 , \$7  })
            2'b?1:
                \strobe$next  = \$13 ;
          endcase
    endcase
    casez (rst)
      1'h1:
          \strobe$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$6 ) begin end
    \i$next  = i;
    casez ({ busy, \$17  })
      2'b?1:
          \i$next  = 6'h00;
      2'b1?:
          casez ({ \$25 , \$21  })
            2'b?1:
                /* empty */;
            2'b1?:
                \i$next  = \$28 [5:0];
          endcase
    endcase
    casez (rst)
      1'h1:
          \i$next  = 6'h00;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$6 ) begin end
    \busy$next  = busy;
    casez ({ busy, \$32  })
      2'b?1:
          \busy$next  = 1'h1;
      2'b1?:
          casez ({ \$40 , \$36  })
            2'b?1:
                \busy$next  = 1'h0;
          endcase
    endcase
    casez (rst)
      1'h1:
          \busy$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$6 ) begin end
    \data$next  = data;
    casez ({ busy, \$44  })
      2'b?1:
          /* empty */;
      2'b1?:
          casez ({ \$52 , \$48  })
            2'b?1:
                /* empty */;
            2'b1?:
                \data$next  = { data[30:0], sdi };
          endcase
    endcase
    casez (rst)
      1'h1:
          \data$next  = 32'd520109572;
    endcase
  end
  assign \$27  = \$28 ;
  assign \$sample$s$sck$sync$1$next  = sck;
  assign \$sample$s$cs$sync$1$next  = cs;
endmodule

module swalense_top(io_in, io_out);
  wire [1:0] dev_channels;
  wire dev_clk;
  wire [7:0] dev_counter;
  wire dev_cs;
  wire dev_direction;
  wire dev_force_x2;
  wire dev_pwm_signal;
  wire dev_rst;
  wire dev_sck;
  wire dev_sdi;
  wire dev_tx;
  input [7:0] io_in;
  wire [7:0] io_in;
  output [7:0] io_out;
  wire [7:0] io_out;
  dev dev (
    .channels(dev_channels),
    .clk(dev_clk),
    .counter(dev_counter),
    .cs(dev_cs),
    .direction(dev_direction),
    .force_x2(dev_force_x2),
    .pwm_signal(dev_pwm_signal),
    .rst(dev_rst),
    .sck(dev_sck),
    .sdi(dev_sdi),
    .tx(dev_tx)
  );
  assign io_out = { dev_counter[4:0], dev_direction, dev_pwm_signal, dev_tx };
  assign { dev_sdi, dev_sck, dev_cs, dev_force_x2, dev_channels } = io_in[7:2];
  assign dev_rst = io_in[1];
  assign dev_clk = io_in[0];
endmodule

